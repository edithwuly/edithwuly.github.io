<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Edith Wu"><meta name=description content="
    
      Bidirectional Encoder Representation from Transformer(Bert) Bert的基本理解 Bert是一个能够适应各类NLP问题的通用预训练架构。其通过在大量的训练语料上以自监督学习的方式学习到词的特征表
    
  "><meta name=theme-color content="#ffffff" media="(prefers-color-scheme: light)"><meta name=theme-color content="#2f3437" media="(prefers-color-scheme: dark)"><meta property="og:title" content="Bert-GPT-ELMo-XLNet"><meta property="og:description" content="Bidirectional Encoder Representation from Transformer(Bert) Bert的基本理解 Bert是一个能够适应各类NLP问题的通用预训练架构。其通过在大量的训练语料上以自监督学习的方式学习到词的特征表"><meta property="og:type" content="article"><meta property="og:url" content="https://edithwuly.github.io/posts/bert-gpt-elmo-xlnet/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-06T15:10:05+08:00"><meta property="article:modified_time" content="2023-06-03T21:32:34+08:00"><meta itemprop=name content="Bert-GPT-ELMo-XLNet"><meta itemprop=description content="Bidirectional Encoder Representation from Transformer(Bert) Bert的基本理解 Bert是一个能够适应各类NLP问题的通用预训练架构。其通过在大量的训练语料上以自监督学习的方式学习到词的特征表"><meta itemprop=datePublished content="2022-09-06T15:10:05+08:00"><meta itemprop=dateModified content="2023-06-03T21:32:34+08:00"><meta itemprop=wordCount content="3040"><meta itemprop=keywords content="NLP,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bert-GPT-ELMo-XLNet"><meta name=twitter:description content="Bidirectional Encoder Representation from Transformer(Bert) Bert的基本理解 Bert是一个能够适应各类NLP问题的通用预训练架构。其通过在大量的训练语料上以自监督学习的方式学习到词的特征表"><base href=https://edithwuly.github.io/posts/bert-gpt-elmo-xlnet/><title>Bert-GPT-ELMo-XLNet |Edith Wu's Blog</title><script type=text/javascript data-cfasync=false>(function(){const e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light",t=localStorage.getItem("theme")||e;t==="dark"&&document.documentElement.classList.toggle("dark",!0)})()</script><link rel=preload href=/scss/main.min.15ff913a7c68271b8dfe025165a295fc7f7e71b619be86a0a783ac85ae2d06d5.css as=style integrity="sha256-Ff+ROnxoJxuN/gJRZaKV/H9+cbYZvoagp4Osha4tBtU="><link rel=stylesheet href=/scss/main.min.15ff913a7c68271b8dfe025165a295fc7f7e71b619be86a0a783ac85ae2d06d5.css integrity="sha256-Ff+ROnxoJxuN/gJRZaKV/H9+cbYZvoagp4Osha4tBtU="><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.slim.min.js integrity="sha512-6ORWJX/LrnSjBzwefdNUyLCMTIsGoNP6NftMy2UAm1JBm6PRZCO1d7OHBStWpVFZLO+RerTvqX/Z9mBFfCJZ4A==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script type=text/javascript src=https://edithwuly.github.io/js/main.min.d3dc4ae06146fcd28c39c26bb3782194ead5431e1b78a83f4fa3b71f44820ced.js integrity="sha256-09xK4GFG/NKMOcJrs3ghlOrVQx4beKg/T6O3H0SCDO0="></script>
<link rel=icon href=/img/favicon.ico type=image/x-icon><link rel=shortcut href=/img/favicon.ico type=image/x-icon><link rel=apple-touch-icon href=/img/apple-touch-icon.png><link rel=mask-icon href=/img/icon.svg><link rel=alternate type=application/rss+xml title=Bert-GPT-ELMo-XLNet href=/index.xml><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Noto+Sans:wght@300;400;500;700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/js/all.min.js integrity="sha512-6PM0qYu5KExuNcKt5bURAoT6KCThUmHRewN3zUFNaoI6Di7XJPTMoT6K0nsagZKk2OB4L7E3q1uQKHNHd4stIQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js integrity=sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13 crossorigin=anonymous></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Bert-GPT-ELMo-XLNet","headline":"Bert-GPT-ELMo-XLNet","alternativeHeadline":"","description":"Bidirectional Encoder Representation from Transformer(Bert) Bert的基本理解 Bert是一个能够适应各类NLP问题的通用预训练架构。其通过在大量的训练语料上以自监督学习的方式学习到词的特征表","inLanguage":"zh-Hans","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/edithwuly.github.io\/posts\/bert-gpt-elmo-xlnet\/"},"author":{"@type":"Person","name":"Edith Wu"},"creator":{"@type":"Person","name":"Edith Wu"},"accountablePerson":{"@type":"Person","name":"Edith Wu"},"copyrightHolder":"Edith Wu\u0027s Blog","copyrightYear":"2022","dateCreated":"2022-09-06T15:10:05.00Z","datePublished":"2022-09-06T15:10:05.00Z","dateModified":"2023-06-03T21:32:34.00Z","publisher":{"@type":"Organization","name":"Edith Wu's Blog","url":"https://edithwuly.github.io","logo":{"@type":"ImageObject","url":"https:\/\/edithwuly.github.io\/img\/icon.svg","width":"32","height":"32"}},"image":"https://edithwuly.github.io/img/icon.svg","url":"https:\/\/edithwuly.github.io\/posts\/bert-gpt-elmo-xlnet\/","wordCount":"3040","genre":["NLP"],"keywords":["NLP"]}</script></head><body><div class=meta><h1 class=title>Edith Wu's Blog</h1><h2 class=subtitle>@edithwuly</h2><ul class=social><li><a href=https://github.com/edithwuly title=GitHub><i class="fa-brands fa-github"></i></a></li><li><a href=/index.xml title=RSS><i class="fa-solid fa-rss"></i></a></li><li><i class="fa-solid fa-grip-lines-vertical"></i></li><li><a class=toggle-color-scheme title="Toggle Color Scheme"><i class="fa-solid fa-circle-half-stroke"></i></a></li></ul><nav><ul class=menu><li><a href=/>Home</a></li><li><a href=/posts>Posts</a></li><li><a href=/categories>Catagories</a></li></ul></nav></div><div id=content><section id=main><h1 id=title>Bert-GPT-ELMo-XLNet</h1><div class=summary-meta><span>2022-09-06
•
<a href=/categories/nlp>NLP</a></span></div><div class=tags><a href=/tags/nlp><div class=tag>#NLP</div></a></div><div class=container><article id=content data-bs-spy=scroll data-bs-target=#TableOfContents><h2 id=bidirectional-encoder-representation-from-transformerbert>Bidirectional Encoder Representation from Transformer(Bert)</h2><h3 id=bert的基本理解>Bert的基本理解</h3><p>Bert是一个能够适应各类NLP问题的通用预训练架构。其通过在大量的训练语料上以自监督学习的方式学习到词的特征表示，使得不同的NLP任务只需要对Bert进行微调，就能达到预期的效果，而不需要重新设计模型架构。</p><h3 id=bert的预训练任务>Bert的预训练任务</h3><p>BERT是一个多任务模型，是由两个自监督任务组成。</p><h4 id=masked-language-modelmlm>Masked Language Model(MLM)：</h4><p>在MLM任务的训练过程中，输入语料中15%的词会被随机Mask掉，而在该语料多次参与训练的过程中，80%的时候被Mask的词会被替换成[Mask]，10%的时候会被替换成其他任意的词，10%的时候会保留原词。然后，模型根据上下文预测被Mask的词。</p><p>因为如果每次都把被Mask掉的词替换成[Mask]，则模型则可能不会学习到该次的特征表示，而随机替换成任意词，则是为了不让模型意识到[Mask]与原词的关系。</p><p>通过MLM，使得Bert模型能够更好地根据上下文预测当前词，并且赋予了模型一定程度的纠错能力。</p><h4 id=next-sentence-predictionnsp>Next Sentence Prediction(NSP)：</h4><p>在NSP任务的训练过程中，输入语料为多对连续的句子，将50%的句子对中的一句换成其他任意的句子，使得连续的句子对和不连续的句子比例为1:1。然后，模型判断当前句子对是否连续。</p><p>通过NSP，使得Bert模型能够理解句子之间的关系。</p><h3 id=bert的结构>Bert的结构</h3><center><img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=/pic/Bert_structure.png><br><div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">Bert的结构</div></center><p>上图为Bert的结构，由多个Transformer全连接层组成，因此Bert能够结合当前词上下文的语境进行预测。</p><p>Bert的输入是一个句子对的 Word Embedding + Position Encoding + Segment Encoding，在首句的句首加上一个特殊的Token[CLS]，在首句和尾句的句尾也加上一个特殊的Token[SEP]。其中，Segment Encoding只有两种状态，用来标记该词属于首句还是尾句。</p><h3 id=bert的fine-tuning>Bert的Fine-Tuning</h3><center><img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=/pic/Bert_Fine-Tuning.png><br><div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">Fine-Tuning的四种形式</div></center><p>上图为对Bert模型进行Fine-Tuning的四种主要形式，对应四种主要的NLP任务。</p><ol><li><p>对于普通的分类任务，输入是一个序列，所有的Token都是属于同一个Segment，即Segment Encoding相同，可以对[CLS]的最后一层输出使用分类器进行分类。</p></li><li><p>对于相似度计算的任务，输入是两个序列，只需要对[CLS]的最后一层输出使用分类器进行分类。</p></li><li><p>对于问答的任务，输入是问题序列和一段包含答案的paragraph序列，输出为答案在paragraph序列中的开始和结束位置。</p></li><li><p>对于序列标注的任务，比如命名实体识别，输入是一个序列，需要对除了[CLS]和[SEP]之外的每个时刻的最后一层输出进行分类。</p></li></ol><h3 id=问题>问题</h3><ol><li><p>MLM任务使得Bert能够借助上下文理解语义，但同时导致其预训练的数据与微调的数据不匹配，因此其适合处理自然语义理解类任务，不适合自然语言生成式任务。</p></li><li><p>由于Bert模型要求序列的长度必须一致，如果过长则需要截断，过短则用padding补齐，因此其适合句子和段落级别的任务，不适用于文档级别的任务。</p></li></ol><h2 id=generative-pre-training-transformergpt>Generative Pre-training Transformer(GPT)</h2><h3 id=gpt的基本理解>GPT的基本理解</h3><p>GPT的思想与Bert类似，也是通过无标签的数据上训练得到一个通用的语言模型，然后再根据特定的任务进行微调。其采用多层单向Transformer作为特征抽取器。</p><h3 id=gpt的结构>GPT的结构</h3><center><img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=/pic/GPT_structure.png><br><div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">GPT的结构</div></center><p>上图为GPT的结构，与Bert类似，但是采用的是单向Transformer，即训练时通过Mask Multi-Head Attention模块遮蔽Ground Truth中当前时刻之后的词。输入为当前词的Word Embedding + Position Encoding。</p><p>与Bert类似，GPT在完成预训练之后，不同的NLP任务只需要对其进行微调即可。</p><p>GPT作为单向语言模型，与Bert不同，无法同时捕捉上下文信息，因此更适合自然语言生成式任务，不适合自然语言理解类任务。</p><h3 id=gpt-2和gpt-3>GPT-2和GPT-3</h3><table><thead><tr><th style=text-align:center>模型</th><th style=text-align:center>参数数量</th><th style=text-align:center>预训练数据量</th></tr></thead><tbody><tr><td style=text-align:center>GPT</td><td style=text-align:center>1.17亿</td><td style=text-align:center>约5GB</td></tr><tr><td style=text-align:center>GPT-2</td><td style=text-align:center>15 亿</td><td style=text-align:center>40GB</td></tr><tr><td style=text-align:center>GPT-3</td><td style=text-align:center>1750 亿</td><td style=text-align:center>45TB</td></tr></tbody></table><p>GPT-2和GPT-3的目标是进一步提高GPT模型的泛化能力。GPT-2和GPT-3相比GPT-1，没有对模型结构进行过多的创新与设计，而是使用了更多的参数和更大的数据集。GPT-2和GPT-3验证了通过增加参数数量和预训练数据量，得到模型具有更高的泛化能力，可以在仅给定任务说明和少量示例的情况下可以迁移到其他NLP任务中，不需要额外的Fine-Tuning样本进行有监督训练。</p><h2 id=embedding-from-language-modelelmo>Embedding from Language Model(ELMo)</h2><h3 id=elmo的基本理解>ELMo的基本理解</h3><p>由于传统的Word Embedding都是固定的，即每个词有唯一的Word Embedding，因此不能很好地解决一词多义的情况。ELMo利用了多层双向的LSTM结构，其中低层的LSTM用于捕捉比较简单的语法信息，高层的LSTM捕捉依赖于上下文的语义信息，根据当前上下文对Word Embedding进行动态调整。</p><h3 id=elmo的结构>ELMo的结构</h3><center><img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=/pic/ELMo_structure.png><br><div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">ELMo的结构</div></center><p>上图为ELMo的结构，输入为当前词的Word Embedding，主体部分由一个从左到右的多层LSTM和一个从右往左的多层LSTM构成，前者用于捕捉当前词与前文的关系，后者用于捕捉与后文的关系。最后将两者的输出与当前词的Word Embedding加权求和后作为当前词根据上下文调整后的Contextual Embedding。</p><p>虽然ELMo采用了两个多层LSTM，一个用于捕捉上文信息，一个用于捕捉下文信息，但是由于RNN的顺序结构，仍然无法做到同时捕捉上下文信息，因此仍为单向语言模型，与GPT相同，更适合自然语言生成式任务，不适合自然语言理解类任务。同时，ELMo所使用的LSTM相对于Transformer特征捕捉的能力也较弱。</p><h2 id=xlnet>XLNet</h2><h3 id=xlnet的基本理解>XLNet的基本理解</h3><p>由于以Bert为代表的autoencoding(AE)language model虽然可以捕捉上下语言特征，但是由于Fine-Tuning的数据中没有MASK，使得与预训练数据不一致，容易引入误差。同时，以GPT为代表的autoregressive(AR)language model为单向语言模型，无法同时捕捉上下文信息。</p><p>为了兼顾AR的方法可以更好地学习单词之间依赖关系的优点，以及AE的方法可以更好地利用深层的双向信息的优点，XLNet使用了Permutation Language Model(PLM)的方法。</p><p>XLNet将句子中的单词随机排列，然后采用AR的方式预测末尾的几个单词，这使得在预测单词的时候就可以同时利用该单词双向的信息，并且能学到单词间的依赖。</p><h3 id=xlnet的结构>XLNet的结构</h3><center><img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=/pic/XLNet_structure.png><br><div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">XLNet的结构</div></center><p>上图为XLNet的结构。XLNet的输入为句子的 Word Embedding 和 Position Encoding，采用了Two-Stream Self-Attention机制，通过Attention掩码机制模拟句子中单词的随机排列，即仅向下层传递打乱后该单词位置之前的单词信息，其中Content Stream与传统的transformer attention机制相同，向下层传递该单词及打乱后其位置之前的单词内容信息，而Query Stream则向下层传递该单词的原始位置信息以及打乱后其位置之前的单词内容信息。</p><p>XLNet还采用了Segment Recurrence Mechanism(段循环)机制，即将上一个句子输出的信息保存下来，用于当前句子的计算，使模型可以拥有更广阔的上下文信息。同时，为了避免引入上一个句子的信息后所导致不同单词拥有相同的Positional Encoding的问题，XLNet采用了Relative Positional Encoding(相对位置编码)，即以单词之间的相对位置作为Position Encoding。</p><h2 id=reference>Reference</h2><p><a href=https://zhuanlan.zhihu.com/p/48612853>https://zhuanlan.zhihu.com/p/48612853</a>
<a href=https://wmathor.com/index.php/archives/1456/>https://wmathor.com/index.php/archives/1456/</a>
<a href=https://www.cnblogs.com/gczr/p/11785930.html>https://www.cnblogs.com/gczr/p/11785930.html</a>
<a href=http://fancyerii.github.io/2019/03/09/bert-theory/>http://fancyerii.github.io/2019/03/09/bert-theory/</a>
<a href=https://www.cnblogs.com/sandwichnlp/p/11947627.html>https://www.cnblogs.com/sandwichnlp/p/11947627.html</a>
<a href=https://zhuanlan.zhihu.com/p/350017443>https://zhuanlan.zhihu.com/p/350017443</a>
<a href=https://zhuanlan.zhihu.com/p/200978538>https://zhuanlan.zhihu.com/p/200978538</a>
<a href=https://zhuanlan.zhihu.com/p/72309137>https://zhuanlan.zhihu.com/p/72309137</a>
<a href=https://zhuanlan.zhihu.com/p/63115885>https://zhuanlan.zhihu.com/p/63115885</a>
<a href=https://www.jianshu.com/p/2b5b368cbaa0>https://www.jianshu.com/p/2b5b368cbaa0</a></p></article><aside><span>Contents</span><nav id=TableOfContents><ul><li><a href=#bidirectional-encoder-representation-from-transformerbert>Bidirectional Encoder Representation from Transformer(Bert)</a><ul><li><a href=#bert的基本理解>Bert的基本理解</a></li><li><a href=#bert的预训练任务>Bert的预训练任务</a></li><li><a href=#bert的结构>Bert的结构</a></li><li><a href=#bert的fine-tuning>Bert的Fine-Tuning</a></li><li><a href=#问题>问题</a></li></ul></li><li><a href=#generative-pre-training-transformergpt>Generative Pre-training Transformer(GPT)</a><ul><li><a href=#gpt的基本理解>GPT的基本理解</a></li><li><a href=#gpt的结构>GPT的结构</a></li><li><a href=#gpt-2和gpt-3>GPT-2和GPT-3</a></li></ul></li><li><a href=#embedding-from-language-modelelmo>Embedding from Language Model(ELMo)</a><ul><li><a href=#elmo的基本理解>ELMo的基本理解</a></li><li><a href=#elmo的结构>ELMo的结构</a></li></ul></li><li><a href=#xlnet>XLNet</a><ul><li><a href=#xlnet的基本理解>XLNet的基本理解</a></li><li><a href=#xlnet的结构>XLNet的结构</a></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></aside></div><script id=giscus src=https://giscus.app/client.js data-repo data-repo-id data-category data-category-id data-mapping=og:title data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en crossorigin=anonymous async></script>
<script>const element=document.getElementById("giscus");if(element){const e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light",t=localStorage.getItem("theme")||e;element.setAttribute("data-theme",t)}</script></section></div><footer><div><p class=footer>© 2023 Edith Wu. This site is licensed under a Creative Commons Attribution 4.0 International license.<br>Theme <a href=https://github.com/rudeigerc/yggdrasill>Yggdrasill</a> |
Powered by <a href=https://gohugo.io>Hugo</a></p></div></footer><button class=scroll-to-top>
<i class="fa-solid fa-angle-up"></i></button></body></html>